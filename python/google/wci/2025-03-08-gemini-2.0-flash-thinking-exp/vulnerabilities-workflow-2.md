## Combined Vulnerability List

### Insecure Protocol Matching

- Description:
    1. A user clicks on a WhatsApp ad, triggering a request to the `/webhook` endpoint. This generates a unique protocol and stores it in the `pending_leads` table, associated with the click identifier (e.g., gclid).
    2. The user is redirected to WhatsApp with a pre-filled message that includes this generated protocol.
    3. An attacker can obtain a valid protocol by initiating the click-to-chat flow themselves or intercepting network requests.
    4. The attacker then sends a WhatsApp message to the business WhatsApp account. This message includes the valid protocol obtained in the previous step.
    5. The WCI webhook at `/webhook-wci` receives this message.
    6. The `process_message` function, along with the `get_protocol_by_phone` helper function, extracts the protocol from the attacker's message using a regular expression.
    7. The extracted protocol and the attacker's phone number are then saved in the `leads` table in BigQuery using `data_source.save_phone_protocol_match(sender, protocol)`. This action incorrectly links the attacker's phone number to the valid protocol.
    8. Subsequently, when the system attempts to match conversions based on this protocol, it will incorrectly attribute the conversion to the attacker's phone number instead of the legitimate user who originally clicked the ad.

- Impact:
    - False Conversion Attribution: Attackers can falsely claim conversions for ad clicks that were not initiated by them. This leads to inaccurate advertising metrics and potentially inflated conversion counts for attacker-controlled interactions.
    - Skewed Advertising Metrics:  The vulnerability allows manipulation of conversion data, leading to unreliable reporting and potentially misinformed decisions regarding advertising campaigns. Advertisers may be charged for conversions that are not genuine, and the effectiveness of WhatsApp campaigns may be misrepresented.

- Vulnerability Rank: High

- Currently Implemented Mitigations:
    - None. There is no mechanism in the provided code to validate the legitimacy or origin of the protocol received in the webhook. The authentication implemented using `auth_required` decorator is only applied to the GET request for webhook verification (`/webhook-wci` endpoint for GET requests), not to the POST request that processes incoming messages.

- Missing Mitigations:
    - Protocol Validation: Implement validation to check if a received protocol is valid, expected, and not already used. This could involve:
        - Timestamp-based validation: Protocols could be associated with a short expiration time window.
        - Single-use protocol mechanism: Once a protocol is used to register a conversion, it should be invalidated and prevent reuse.
        - Server-side session management: Track generated protocols in a server-side session and validate against active sessions when processing webhook messages.
    - Sender Verification: While full phone number verification in WhatsApp might be complex, consider implementing:
        - Rate limiting: Limit the number of protocol associations from a single phone number within a specific timeframe to detect suspicious activity.
        - Anomaly detection: Monitor patterns of protocol usage to identify and flag unusual activities, such as rapid reuse of the same protocol from different phone numbers.
    - Nonce/State Parameter:
        - Introduce a nonce or state parameter during the initial click-to-chat request. This parameter should be included in the pre-filled WhatsApp message and validated when the webhook receives the message. This would help ensure that the message originates from a legitimate click-to-chat interaction.

- Preconditions:
    - The attacker needs to obtain a valid protocol generated by the system. This can be done through:
        - Interception: Capturing network traffic from a legitimate user's click on a WhatsApp ad.
        - Self-generation: Initiating the click-to-chat process themselves to generate a valid protocol.
    - The attacker must send their WhatsApp message containing the valid protocol to the business WhatsApp account. This message needs to be processed by the webhook `/webhook-wci`.
    - For successful exploitation, the attacker's message with the reused protocol should ideally be processed by the system *before* the legitimate user's message containing the same protocol, or in scenarios where the legitimate user never sends their message.

- Source Code Analysis:
    1. `/app/blueprints/webhook/blueprint.py`: The `process_message` function at the `/webhook-wci` endpoint is responsible for handling incoming WhatsApp messages. It delegates the message processing to a partner-specific class based on the `PARTNER_TYPE` environment variable.
    ```python
    @webhook_page.route("/webhook-wci", methods=["POST"])
    def process_message():
        """
        Process message received
        """
        partner = PartnerFactory(os.environ.get("PARTNER_TYPE")).get()
        partner.process_message(request.get_json())
        return "Success", 200
    ```
    2. `/app/partners/whatsapp/whatsapp_partner.py` (Example Partner Implementation): The `process_message` function in `WhatsAppPartner` (and similar functions in other partner classes like `InfobipPartner`, `TakePartner`, `BotmakerPartner`) extracts the message body, sender's phone number, and receiver's phone number from the webhook payload. It then calls the `get_protocol_by_phone` function from `helpers/webhook/helpers.py` to process the message content.
    ```python
    def process_message(self, payload):
        """
        Process message received
        """
        if (
            payload.get("object") == "whatsapp_business_account"
            and payload.get("entry") is not None
        ):
            for each in payload.get("entry"):
                for change in each["changes"]:
                    if (
                        change["field"] == "messages"
                        and change["value"].get("messages") is not None
                    ):
                        get_protocol_by_phone(
                            change["value"]["messages"][0]["text"]["body"],
                            change["value"]["contacts"][0]["wa_id"],
                            change["value"]["metadata"]["display_phone_number"],
                        )
    ```
    3. `/app/helpers/webhook/helpers.py`: The `get_protocol_by_phone` function extracts the protocol from the message content using a regular expression (`re.search`). If a protocol is found, it directly calls `data_source.save_phone_protocol_match(sender, protocol)` to save the association between the sender's phone number and the extracted protocol in the BigQuery `leads` table. **Crucially, there is no validation step to verify the legitimacy or intended recipient of the protocol before saving this association.**
    ```python
    def get_protocol_by_phone(message: str, sender: str, receiver: str) -> Optional[str]:
        """
        Helper function for getting a generated protocol for a given sender.
        """
        _protocol_message = os.environ.get("PROTOCOL_MESSAGE").strip()
        _ctm_message = os.environ.get("CTM_PROTOCOL_MESSAGE").strip()
        has_protocol = re.search(f"({_protocol_message}|{_ctm_message}) (\w+)", message)
        protocol = None

        if has_protocol:
            protocol = has_protocol.group(2)
            data_source.save_phone_protocol_match(sender, protocol)
            if os.environ.get("ECL_ENABLED").lower() == "true":
                set_protocol_ecl_for_phone(protocol, sender)

        data_source.save_message(message, sender, receiver)
        return protocol
    ```
    4. `/app/data_sources/bigquery/bigquery_data_source.py`: The `save_phone_protocol_match` function inserts the phone number and protocol directly into the `BQ_LEAD_TABLE` in BigQuery without any further checks or validation.
    ```python
    def save_phone_protocol_match(self, phone: str, protocol: str):
        """
        Saves a protocol matched to a number (phone)
        """
        rows_to_insert = [
            {
                "phone": phone,
                "protocol": protocol,
                "timestamp": datetime.datetime.now().timestamp(),
            }
        ]
        errors = self._bq_client.insert_rows_json(BQ_LEAD_TABLE, rows_to_insert)
        if not errors == []:
            raise Exception("Error while creating lead: {}".format(errors))
    ```

- Security Test Case:
    1. **Generate a Valid Protocol:** Use `curl` to request a new protocol from the `/webhook` endpoint:
    ```bash
    curl "https://<your-wci-endpoint>/webhook?id=legitimate_click_id&type=gclid"
    ```
    Note the `protocol` value in the JSON response. Let's assume it is `example_protocol_123`.
    2. **Attacker Sends WhatsApp Message:** Using an attacker-controlled WhatsApp account, send a message to the business WhatsApp number. The message should include the protocol obtained in the previous step. For example, if `PROTOCOL_MESSAGE` is set to "Your protocol is", the message could be: `Your protocol is example_protocol_123`.
    3. **Verify Data in BigQuery:** Query the `BQ_LEAD_TABLE` in BigQuery to confirm that the attacker's phone number is now associated with the protocol `example_protocol_123`. You can use the BigQuery UI or `bq` command-line tool. For instance:
    ```bash
    bq query --nouse_legacy_sql "SELECT phone, protocol FROM `<your-project-id>.<your-bqdataset-name>.leads` WHERE protocol = 'example_protocol_123'"
    ```
    4. **Expected Outcome:** The query should return a row showing the attacker's phone number associated with the protocol `example_protocol_123`, demonstrating successful exploitation of the Insecure Protocol Matching vulnerability. The system incorrectly linked the attacker's phone number to a protocol that was intended for a legitimate user's click, due to the lack of protocol validation in the webhook processing logic.

### Protocol Injection

- Description:
  The application is vulnerable to protocol injection due to insufficient input validation when processing WhatsApp messages.

  1. The application uses a regular expression `f"({_protocol_message}|{_ctm_message}) (\w+)"` in the `get_protocol_by_phone` function to extract the protocol from incoming WhatsApp messages.
  2. This regex is overly permissive, as `\w+` matches any word character (letters, digits, and underscores). This allows an attacker to inject arbitrary strings as valid protocols.
  3. An attacker can craft a WhatsApp message containing the configured `PROTOCOL_MESSAGE` (or `CTM_PROTOCOL_MESSAGE`) followed by a space and a malicious protocol string of their choice.
  4. When the application processes this message, it extracts the attacker-controlled string as the protocol.
  5. This attacker-injected protocol is then saved into the `leads` table in BigQuery, associating it with the attacker's phone number.
  6. This can lead to the injection of fraudulent conversion data, as the system will treat these attacker-generated protocols as legitimate conversion events.

- Impact:
  - Fraudulent conversion data can be injected into the system, leading to inflated or manipulated conversion metrics.
  - Advertisers' conversion reports and campaign performance data can be skewed and unreliable.
  - Malicious actors can exploit this vulnerability to misrepresent advertising performance, potentially harming advertisers or gaining unfair advantages.

- Vulnerability Rank: High

- Currently Implemented Mitigations: None

- Missing Mitigations:
  - Implement robust input validation for the extracted protocol in the `get_protocol_by_phone` function.
    - Validate that the extracted protocol conforms to the expected format (e.g., numeric, alphanumeric with a specific length, or matches a predefined set of valid protocols).
    - Reject or sanitize messages containing invalid protocols.
  - Consider using a more secure protocol generation method if protocol predictability is a concern. However, input validation is the primary mitigation for this specific vulnerability.

- Preconditions:
  - The attacker needs to know the WhatsApp Business Account number configured for the WCI application.
  - The attacker needs to discover the configured `PROTOCOL_MESSAGE` or `CTM_PROTOCOL_MESSAGE`. This can be done by initiating a legitimate lead generation flow or through social engineering.

- Source Code Analysis:
  1. **`app/helpers/webhook/helpers.py:get_protocol_by_phone` function:**
     ```python
     def get_protocol_by_phone(message: str, sender: str, receiver: str) -> Optional[str]:
         ...
         _protocol_message = os.environ.get("PROTOCOL_MESSAGE").strip()
         _ctm_message = os.environ.get("CTM_PROTOCOL_MESSAGE").strip()
         has_protocol = re.search(f"({_protocol_message}|{_ctm_message}) (\w+)", message)
         protocol = None

         if has_protocol:
             protocol = has_protocol.group(2) # Vulnerable line - extracts anything matching \w+
             data_source.save_phone_protocol_match(sender, protocol)
             ...
         ...
         return protocol
     ```
     - This code snippet shows that the `get_protocol_by_phone` function uses a regular expression to extract the protocol from the incoming message.
     - The vulnerable part is `(\w+)` which matches one or more word characters. This regex pattern is too broad and allows any word-like string to be captured as a valid protocol.
     - The extracted `protocol` is directly assigned the value from the regex group without any further validation.

  2. **`app/data_sources/bigquery/bigquery_data_source.py:save_phone_protocol_match` function:**
     ```python
     def save_phone_protocol_match(self, phone: str, protocol: str):
         """
         Saves a protocol matched to a number (phone)
         ...
         """
         rows_to_insert = [
             {
                 "phone": phone,
                 "protocol": protocol, # Vulnerable line - saves unvalidated protocol
                 "timestamp": datetime.datetime.now().timestamp(),
             }
         ]

         errors = self._bq_client.insert_rows_json(BQ_LEAD_TABLE, rows_to_insert)
         ...
     ```
     - The `save_phone_protocol_match` function in `BigQueryDataSource` takes the `protocol` extracted by `get_protocol_by_phone` and directly saves it into the `BQ_LEAD_TABLE`.
     - There is no validation or sanitization of the `protocol` before it is inserted into the database. This means any string that matches the `\w+` regex in `get_protocol_by_phone` will be accepted and stored as a valid protocol.

- Security Test Case:
  1. **Prerequisites:**
     - Deploy the WCI application to Google Cloud.
     - Configure a WhatsApp Business Account and set up the webhook to point to the deployed WCI application's `/webhook-wci` endpoint.
     - Obtain the deployed application's endpoint URL.
     - Determine the configured `PROTOCOL_MESSAGE`. Assume it is "Your protocol is".

  2. **Steps:**
     - Open the WhatsApp application on a mobile device or web browser.
     - Initiate a chat with the configured WhatsApp Business Account number.
     - Compose a message in the chat that starts with the `PROTOCOL_MESSAGE`, followed by a space, and then a fraudulent protocol string. For example: "Your protocol is INJECTED_PROTOCOL_123".
     - Send the message to the WhatsApp Business Account.

  3. **Verification:**
     - Access the Google Cloud Console and navigate to BigQuery.
     - Query the `BQ_LEAD_TABLE` within the configured dataset (e.g., `wci.leads`).
     - Execute a query to search for entries with the injected protocol "INJECTED_PROTOCOL_123". For example: `SELECT * FROM \`<your-project-id>.<your-dataset-name>.leads\` WHERE protocol = 'INJECTED_PROTOCOL_123'`.
     - Check if a new row exists in the `BQ_LEAD_TABLE` where the `protocol` column contains "INJECTED_PROTOCOL_123" and the `phone` column contains the WhatsApp ID of the phone number from which the message was sent.

  4. **Expected Result:**
     - A new row will be present in the `BQ_LEAD_TABLE` with the `protocol` field set to "INJECTED_PROTOCOL_123" and the `phone` field corresponding to the attacker's WhatsApp number. This confirms that the attacker was able to successfully inject a fraudulent protocol into the system by crafting a WhatsApp message.