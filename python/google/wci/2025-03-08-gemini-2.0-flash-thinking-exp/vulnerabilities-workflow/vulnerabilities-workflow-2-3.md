### Vulnerability List

- Vulnerability Name: Insecure Protocol Matching
- Description:
    1. A user clicks on a WhatsApp ad, triggering a request to the `/webhook` endpoint. This generates a unique protocol and stores it in the `pending_leads` table, associated with the click identifier (e.g., gclid).
    2. The user is redirected to WhatsApp with a pre-filled message that includes this generated protocol.
    3. An attacker can obtain a valid protocol. This can be achieved by simply initiating the click-to-chat flow themselves or potentially by intercepting network requests.
    4. The attacker then sends a WhatsApp message to the business WhatsApp account. This message includes the valid protocol obtained in the previous step.
    5. The WCI webhook at `/webhook-wci` receives this message.
    6. The `process_message` function, along with the `get_protocol_by_phone` helper function, extracts the protocol from the attacker's message using a regular expression.
    7. The extracted protocol and the attacker's phone number are then saved in the `leads` table in BigQuery using `data_source.save_phone_protocol_match(sender, protocol)`. This action incorrectly links the attacker's phone number to the valid protocol.
    8. Subsequently, when the system attempts to match conversions based on this protocol, it will incorrectly attribute the conversion to the attacker's phone number instead of the legitimate user who originally clicked the ad.

- Impact:
    - False Conversion Attribution: Attackers can falsely claim conversions for ad clicks that were not initiated by them. This leads to inaccurate advertising metrics and potentially inflated conversion counts for attacker-controlled interactions.
    - Skewed Advertising Metrics:  The vulnerability allows manipulation of conversion data, leading to unreliable reporting and potentially misinformed decisions regarding advertising campaigns. Advertisers may be charged for conversions that are not genuine, and the effectiveness of WhatsApp campaigns may be misrepresented.

- Vulnerability Rank: High

- Currently Implemented Mitigations:
    - None. There is no mechanism in the provided code to validate the legitimacy or origin of the protocol received in the webhook. The authentication implemented using `auth_required` decorator is only applied to the GET request for webhook verification (`/webhook-wci` endpoint for GET requests), not to the POST request that processes incoming messages.

- Missing Mitigations:
    - Protocol Validation: Implement validation to check if a received protocol is valid, expected, and not already used. This could involve:
        - Timestamp-based validation: Protocols could be associated with a short expiration time window.
        - Single-use protocol mechanism: Once a protocol is used to register a conversion, it should be invalidated and prevent reuse.
        - Server-side session management: Track generated protocols in a server-side session and validate against active sessions when processing webhook messages.
    - Sender Verification: While full phone number verification in WhatsApp might be complex, consider implementing:
        - Rate limiting: Limit the number of protocol associations from a single phone number within a specific timeframe to detect suspicious activity.
        - Anomaly detection: Monitor patterns of protocol usage to identify and flag unusual activities, such as rapid reuse of the same protocol from different phone numbers.
    - Nonce/State Parameter:
        - Introduce a nonce or state parameter during the initial click-to-chat request. This parameter should be included in the pre-filled WhatsApp message and validated when the webhook receives the message. This would help ensure that the message originates from a legitimate click-to-chat interaction.

- Preconditions:
    - The attacker needs to obtain a valid protocol generated by the system. This can be done through:
        - Interception: Capturing network traffic from a legitimate user's click on a WhatsApp ad.
        - Self-generation: Initiating the click-to-chat process themselves to generate a valid protocol.
        - Protocol Prediction (Less Likely): While less probable due to the use of UUID and CRC32, if the protocol generation mechanism is predictable, guessing protocols might be feasible.
    - The attacker must send their WhatsApp message containing the valid protocol to the business WhatsApp account. This message needs to be processed by the webhook `/webhook-wci`.
    - For successful exploitation, the attacker's message with the reused protocol should ideally be processed by the system *before* the legitimate user's message containing the same protocol, or in scenarios where the legitimate user never sends their message.

- Source Code Analysis:
    1. `/app/blueprints/webhook/blueprint.py`: The `process_message` function at the `/webhook-wci` endpoint is responsible for handling incoming WhatsApp messages. It delegates the message processing to a partner-specific class based on the `PARTNER_TYPE` environment variable.
    ```python
    @webhook_page.route("/webhook-wci", methods=["POST"])
    def process_message():
        """
        Process message received
        """
        partner = PartnerFactory(os.environ.get("PARTNER_TYPE")).get()
        partner.process_message(request.get_json())
        return "Success", 200
    ```
    2. `/app/partners/whatsapp/whatsapp_partner.py` (Example Partner Implementation): The `process_message` function in `WhatsAppPartner` (and similar functions in other partner classes like `InfobipPartner`, `TakePartner`, `BotmakerPartner`) extracts the message body, sender's phone number, and receiver's phone number from the webhook payload. It then calls the `get_protocol_by_phone` function from `helpers/webhook/helpers.py` to process the message content.
    ```python
    def process_message(self, payload):
        """
        Process message received
        """
        if (
            payload.get("object") == "whatsapp_business_account"
            and payload.get("entry") is not None
        ):
            for each in payload.get("entry"):
                for change in each["changes"]:
                    if (
                        change["field"] == "messages"
                        and change["value"].get("messages") is not None
                    ):
                        get_protocol_by_phone(
                            change["value"]["messages"][0]["text"]["body"],
                            change["value"]["contacts"][0]["wa_id"],
                            change["value"]["metadata"]["display_phone_number"],
                        )
    ```
    3. `/app/helpers/webhook/helpers.py`: The `get_protocol_by_phone` function extracts the protocol from the message content using a regular expression (`re.search`). If a protocol is found, it directly calls `data_source.save_phone_protocol_match(sender, protocol)` to save the association between the sender's phone number and the extracted protocol in the BigQuery `leads` table. **Crucially, there is no validation step to verify the legitimacy or intended recipient of the protocol before saving this association.**
    ```python
    def get_protocol_by_phone(message: str, sender: str, receiver: str) -> Optional[str]:
        """
        Helper function for getting a generated protocol for a given sender.
        """
        _protocol_message = os.environ.get("PROTOCOL_MESSAGE").strip()
        _ctm_message = os.environ.get("CTM_PROTOCOL_MESSAGE").strip()
        has_protocol = re.search(f"({_protocol_message}|{_ctm_message}) (\w+)", message)
        protocol = None

        if has_protocol:
            protocol = has_protocol.group(2)
            data_source.save_phone_protocol_match(sender, protocol)
            if os.environ.get("ECL_ENABLED").lower() == "true":
                set_protocol_ecl_for_phone(protocol, sender)

        data_source.save_message(message, sender, receiver)
        return protocol
    ```
    4. `/app/data_sources/bigquery/bigquery_data_source.py`: The `save_phone_protocol_match` function inserts the phone number and protocol directly into the `BQ_LEAD_TABLE` in BigQuery without any further checks or validation.
    ```python
    def save_phone_protocol_match(self, phone: str, protocol: str):
        """
        Saves a protocol matched to a number (phone)
        """
        rows_to_insert = [
            {
                "phone": phone,
                "protocol": protocol,
                "timestamp": datetime.datetime.now().timestamp(),
            }
        ]
        errors = self._bq_client.insert_rows_json(BQ_LEAD_TABLE, rows_to_insert)
        if not errors == []:
            raise Exception("Error while creating lead: {}".format(errors))
    ```

- Security Test Case:
    1. **Generate a Valid Protocol:** Use `curl` to request a new protocol from the `/webhook` endpoint:
    ```bash
    curl "https://<your-wci-endpoint>/webhook?id=legitimate_click_id&type=gclid"
    ```
    Note the `protocol` value in the JSON response. Let's assume it is `example_protocol_123`.
    2. **Attacker Sends WhatsApp Message:** Using an attacker-controlled WhatsApp account, send a message to the business WhatsApp number. The message should include the protocol obtained in the previous step. For example, if `PROTOCOL_MESSAGE` is set to "Your protocol is", the message could be: `Your protocol is example_protocol_123`.
    3. **Verify Data in BigQuery:** Query the `BQ_LEAD_TABLE` in BigQuery to confirm that the attacker's phone number is now associated with the protocol `example_protocol_123`. You can use the BigQuery UI or `bq` command-line tool. For instance:
    ```bash
    bq query --nouse_legacy_sql "SELECT phone, protocol FROM `<your-project-id>.<your-bqdataset-name>.leads` WHERE protocol = 'example_protocol_123'"
    ```
    4. **Expected Outcome:** The query should return a row showing the attacker's phone number associated with the protocol `example_protocol_123`, demonstrating successful exploitation of the Insecure Protocol Matching vulnerability. The system incorrectly linked the attacker's phone number to a protocol that was intended for a legitimate user's click, due to the lack of protocol validation in the webhook processing logic.