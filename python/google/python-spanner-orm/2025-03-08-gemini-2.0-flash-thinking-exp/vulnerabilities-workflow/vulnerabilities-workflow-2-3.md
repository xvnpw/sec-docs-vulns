## Vulnerability List

### 1. Vulnerability Name: Spanner Query Injection via `ArbitraryCondition`

* Description:
    1. An application developer uses `spanner_orm.ArbitraryCondition` to construct a Spanner query, intending to add flexibility for complex conditions.
    2. The application developer directly incorporates unsanitized user input into the `sql_template` argument of `ArbitraryCondition`.
    3. An attacker, by controlling the user input, can inject malicious Spanner SQL code into the `sql_template`.
    4. When the ORM executes the query, the injected SQL code is executed directly against the Spanner database, potentially bypassing intended ORM logic and security measures.

* Impact:
    * **High:** Successful exploitation allows the attacker to execute arbitrary Spanner queries. This could lead to unauthorized data access, modification, or deletion, depending on the database permissions of the service account used by the application. In the worst case, an attacker might be able to escalate privileges within the Spanner database or gain access to sensitive data.

* Vulnerability Rank: High

* Currently Implemented Mitigations:
    * **None:** The library does not prevent the usage of `ArbitraryCondition` with unsanitized input. The responsibility for sanitization is entirely on the application developer.

* Missing Mitigations:
    * **Input Sanitization/Validation:** The `ArbitraryCondition` should include input sanitization or validation mechanisms to prevent SQL injection. At a minimum, documentation should strongly discourage direct user input in `sql_template` without sanitization.
    * **Principle of Least Privilege Documentation:** Emphasize in documentation to grant the application's Spanner service account only the minimal necessary permissions to reduce the potential impact of query injection.

* Preconditions:
    1. The application uses `spanner_orm.ArbitraryCondition`.
    2. The application incorporates user-supplied input into the `sql_template` argument of `ArbitraryCondition` without proper sanitization.
    3. An attacker has control over this user-supplied input.

* Source Code Analysis:
    1. **File: /code/spanner_orm/condition.py, Class: `ArbitraryCondition`**:
        ```python
        class ArbitraryCondition(Condition):
            """Condition with support for arbitrary SQL."""

            def __init__(
                self,
                sql_template: str,
                substitutions: Mapping[str, Substitution] = immutabledict.immutabledict(),
                *,
                segment: Segment,
            ):
                """Initializer.

                Args:
                  sql_template: string.Template-compatible template string for the SQL.
                  substitutions: Substitutions to make in sql_template.
                  segment: Segment for this Condition.
                """
                super().__init__()
                self._sql_template = string.Template(sql_template) # [VULNERABILITY]: SQL template is directly taken as input
                self._substitutions = substitutions
                self._segment = segment

                # This validates the template.
                self._sql_template.substitute({k: '' for k in self._substitutions})
        ```
        The `__init__` method of `ArbitraryCondition` directly takes `sql_template` as a string argument and uses `string.Template` to create a template. There is no input validation or sanitization performed on `sql_template`.

    2. **File: /code/spanner_orm/query.py, Class: `SpannerQuery`, Method: `_where`**:
        ```python
        def _where(self) -> Tuple[str, Dict[str, Any], Dict[str, Any]]:
            """Processes the WHERE segment of the SQL query."""
            sql, sql_parts, parameters, types = '', [], {}, {}
            wheres = self._segments(condition.Segment.WHERE)
            for where in wheres:
              where.suffix = str(self._next_param_index() + len(parameters))
              sql_parts.append(where.sql()) # [EXECUTION]: Vulnerable SQL from ArbitraryCondition is added to the query
              parameters.update(where.params())
              types.update(where.types())
            if sql_parts:
              sql = ' WHERE {}'.format(' AND '.join(sql_parts))
            return (sql, parameters, types)
        ```
        The `_where` method iterates through conditions of type `WHERE` and directly appends the SQL generated by `where.sql()` to the query. If a condition is an `ArbitraryCondition` with malicious SQL in its `sql_template`, this SQL will be included in the final Spanner query.

    3. **Visualization:**

    ```
    UserInput (attacker controlled) --> Application Code --> ArbitraryCondition (sql_template) --> SpannerQuery._where() --> Raw SQL Query --> Spanner Database (SQL Injection)
    ```

* Security Test Case:
    1. **Setup:** Assume an application using `spanner_orm` with a `TestModel` and an endpoint that takes user input to filter `TestModel` records using `ArbitraryCondition`. For example, filtering based on a user-provided SQL fragment.
    2. **Attacker Input:** The attacker crafts a malicious input designed to inject SQL code. Example malicious input for `sql_template`: `1=1; DELETE FROM TestTable WHERE TRUE; --` . The intended query might be something like `SELECT * FROM TestTable WHERE <user_provided_condition>`.
    3. **Application Execution:** The application constructs an `ArbitraryCondition` using the malicious input as `sql_template` and executes a `where()` query using this condition.
    4. **Spanner Query Execution:** The ORM generates a Spanner query that includes the injected SQL. For example, the final query might become `SELECT * FROM TestTable WHERE 1=1; DELETE FROM TestTable WHERE TRUE; --`.
    5. **Verification:** The attacker checks if the injected SQL is executed. In this example, the attacker verifies if all rows in `TestTable` are deleted, demonstrating successful SQL injection. This can be verified by attempting to retrieve data from the table after the attack.

---