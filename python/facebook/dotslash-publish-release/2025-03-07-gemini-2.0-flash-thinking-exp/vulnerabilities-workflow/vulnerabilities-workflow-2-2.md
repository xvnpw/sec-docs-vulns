- Vulnerability Name: Supply Chain Vulnerability via Propagation of Compromised Release Artifacts
- Description:
    1. An attacker compromises the GitHub workflow responsible for building and uploading the initial release artifacts.
    2. The attacker modifies this workflow to inject malware into the executables being built.
    3. The compromised workflow proceeds to upload these malware-infected executables as release artifacts to a GitHub release.
    4. The `dotslash-publish-release` GitHub Action is configured to run after the successful completion of the release artifact upload workflow.
    5. The `dotslash-publish-release` action automatically triggers and fetches the release assets (which now include the malware-infected executables) from the GitHub release.
    6. The action generates DotSlash files. These files are configured to download and execute the fetched release artifacts and will therefore point to the malware-infected executables.
    7. The `dotslash-publish-release` action uploads these newly generated DotSlash files to the same GitHub release, making them available for users to download.
    8. Unsuspecting users download and execute the DotSlash files, which in turn download and execute the malware-infected executables from the GitHub release, compromising their systems.
- Impact: Users who download and use the generated DotSlash files will unknowingly download and execute malware, potentially leading to complete system compromise, data theft, or other malicious activities. This represents a significant supply chain vulnerability as it allows for the distribution of malware through a seemingly legitimate distribution mechanism (DotSlash files from a trusted GitHub release).
- Vulnerability Rank: Critical
- Currently Implemented Mitigations:
    - Hash verification: The `process_config.py` script calculates a cryptographic hash (BLAKE3 or SHA256) of each downloaded release artifact using the `compute_hash` function. This hash is included in the generated DotSlash file. When a user uses `dotslash-cli` to install software via a DotSlash file, `dotslash-cli` verifies the hash of the downloaded artifact against the hash in the DotSlash file. This mechanism provides integrity checking of the artifacts *at the time of installation by the end-user*, assuming the DotSlash file itself has not been tampered with after generation and upload by this action.
- Missing Mitigations:
    - Trust in upstream workflows: The action implicitly trusts the integrity of the release artifacts provided by the upstream GitHub workflows. There is no mechanism within this action to validate the source or integrity of the release artifacts *before* generating the DotSlash files. The action assumes that if artifacts are present in the GitHub release, they are legitimate and safe.
    - Lack of artifact provenance verification: The action does not implement any form of provenance verification for the release artifacts. It does not check for signatures, attestations, or any other cryptographic proof that the artifacts were genuinely produced by the expected source and have not been tampered with before being included in the release.
- Preconditions:
    - Compromised Release Workflow: The primary precondition is that the GitHub workflow responsible for building and uploading the initial release artifacts must be compromised by an attacker. This compromise allows the attacker to inject malware into the artifacts before they are released.
    - Successful Artifact Upload: The compromised workflow must successfully upload the malware-infected artifacts to a GitHub release.
    - `dotslash-publish-release` Action Configuration: The `dotslash-publish-release` action must be configured to run *after* the workflow that uploads the release artifacts. This ensures that the action processes the compromised artifacts.
- Source Code Analysis:
    - `process_config.py`:
        - `get_release_assets(*, tag: str, github_repository)`: This function uses the GitHub CLI (`gh release view --json assets`) to fetch the list of assets associated with a given release tag. It retrieves asset metadata (name, URL, size, etc.) from GitHub. There is no validation or integrity check performed on these assets at this stage. The action simply trusts the information provided by the GitHub API.
        - `compute_hash(gh_repo_arg: str, temp_dir: str, tag: str, name: str, hash_algo: HashAlgorithm, size: int) -> str`: This function is responsible for downloading a specific release asset using `gh release download` and computing its cryptographic hash (either BLAKE3 or SHA256, as configured). The downloaded file's size is also verified against the size reported in the release metadata. While this function performs hash calculation, it operates on artifacts that have already been uploaded to the release, meaning it will compute the hash of potentially compromised artifacts if the upstream workflow was compromised.
        - `generate_manifest_file(name: str, gh_repo_arg: str, tag: str, platform_entries, include_http_provider: bool, include_github_release_provider: bool) -> str`: This function constructs the DotSlash manifest file. It iterates through the platform entries, retrieves the pre-computed hash from `compute_hash`, and includes the artifact's URL, size, hash, and other metadata in the JSON manifest. The generated manifest is then written to a file.
        - The overall flow in `_main()` function shows that the action first retrieves release assets, then iterates through configured outputs, maps platforms to assets, and generates manifest files using `generate_manifest_file`. The vulnerability arises because the action operates on and propagates whatever artifacts are present in the GitHub release *without* questioning their origin or integrity beyond basic hash calculation of already uploaded artifacts.
- Security Test Case:
    1. Setup: Create a test GitHub repository and configure a workflow to build and release a simple executable artifact (e.g., a "hello world" program). Include the `dotslash-publish-release` action in `.github/workflows/dotslash.yml` to run after the release workflow.
    2. Compromise Artifact: In the release workflow, before the artifact upload step, modify the build process to inject a benign "malware" payload into the executable artifact. For example, prepend a command that prints a warning message to stderr before executing the original program's logic.
    3. Create Release: Run the release workflow. This will build the compromised artifact and upload it to a new GitHub release. The `dotslash-publish-release` action will automatically trigger after the release is created.
    4. Verify DotSlash File Generation: Check the GitHub release. The `dotslash-publish-release` action should have added DotSlash files to the release. Download one of these DotSlash files.
    5. Execute DotSlash File: On a test machine with `dotslash-cli` installed, make the downloaded DotSlash file executable (`chmod +x <dotslash-file>`) and run it (`./<dotslash-file>`).
    6. Observe Malware Execution: Observe the execution of the DotSlash file. The "warning message" (or other injected payload) should be printed to stderr *before* the "hello world" program executes, demonstrating that the compromised artifact has been successfully distributed and executed via the DotSlash file.
    7. (Optional) Hash Mitigation Check (Non-blocking in this scenario): To demonstrate the hash mitigation, after step 4, manually modify the released artifact on GitHub (if possible, or simulate this by modifying the downloaded artifact locally before running dotslash-cli against a local DotSlash file). When `dotslash-cli` attempts to install using the DotSlash file referencing the modified artifact, it should fail with a hash mismatch error, showing that the hash verification mechanism *would* detect tampering *after* DotSlash file generation, but it does not prevent the initial propagation of compromised artifacts if they are already present in the release when the DotSlash files are generated.