### Vulnerability List:

- Vulnerability Name: Missing HMAC Verification in SIM Data Decryption
- Description:
    1. The `encrypted-sim-gen.py` script encrypts sensitive SIM data using AES-CBC and HMAC-SHA512 for integrity.
    2. The `SimDefinition.decrypt` function is intended for internal decryption of the encrypted SIM data for verification purposes within the script.
    3. However, the `decrypt` function extracts the HMAC (message authentication code) from the encrypted data but **fails to verify** if the HMAC is valid before proceeding with decryption.
    4. An attacker who can intercept or manipulate the `encryptedCredentials` after encryption can modify the ciphertext.
    5. When the `decrypt` function is used on this modified `encryptedCredentials`, it will proceed to decrypt the tampered ciphertext because it does not check the HMAC.
    6. This lack of HMAC verification means that the integrity of the encrypted SIM data is not checked during decryption in the provided `decrypt` function.
    7. If partners were to use or adapt this flawed decryption logic in their upload endpoint implementation, they would be vulnerable to accepting tampered encrypted SIM data.
- Impact:
    - High. If the upload endpoint (receiving system) also fails to implement HMAC verification, an attacker could potentially modify the encrypted SIM data in transit.
    - By tampering with the ciphertext part of `encryptedCredentials`, an attacker could inject malicious or incorrect SIM data, such as ICCID, IMSI, KI, and OPC.
    - If the receiving system trusts the decrypted data without proper validation, this could lead to unauthorized SIM provisioning, service disruption, or other security breaches depending on how the SIM data is used in the backend systems.
- Vulnerability Rank: High
- Currently Implemented Mitigations:
    - None. While HMAC is calculated during the encryption process in the `encrypt` function, there is **no HMAC verification** implemented in the `decrypt` function within the provided `encrypted-sim-gen.py` script.
- Missing Mitigations:
    - **Implement HMAC Verification in Decryption:** The `decrypt` function (and any real-world decryption process at the upload endpoint) must be modified to perform HMAC verification.
        - After extracting the HMAC, IV, and ciphertext from the `encryptedCredentials`, the decryption process should recalculate the HMAC of the IV and ciphertext using the authentication transport key.
        - This recalculated HMAC must be compared to the extracted HMAC.
        - If the HMAC values do not match, it indicates data tampering, and the decryption process must be aborted with an error.
        - Only if the HMAC verification is successful should the process proceed to decrypt the ciphertext using AES-CBC and unpad the result.
- Preconditions:
    1. **Vulnerable Decryption Implementation:** The primary precondition is that the system or partner implementing the decryption of `encryptedCredentials` (especially at the upload endpoint) must **fail to implement HMAC verification**. If a robust upload endpoint correctly verifies the HMAC, this vulnerability in the provided script's `decrypt` function would not directly impact the security of the upload process, although it still represents a flaw in the example code.
    2. **Man-in-the-Middle or Data Modification:** An attacker needs to be in a position to intercept and modify the `encryptedCredentials` after it has been generated by the `encrypted-sim-gen.py` script and before it is processed and decrypted by the receiving system.
- Source Code Analysis:
    - The vulnerability is located in the `SimDefinition.decrypt` function in `/code/encrypted-sim-gen.py`.

    ```python
    def decrypt(self, transportKey, vendorPublicKey):
        properties = self.jsonDefinition["properties"]
        encryptedSecret = bytes.fromhex(properties["encryptedCredentials"])

        del self.jsonDefinition["properties"]["encryptedCredentials"]

        cipherText = []
        try:
            if (len(encryptedSecret) < 33):
                raise ValueError()
            mac = encryptedSecret[:64] # HMAC is extracted here
            iv = encryptedSecret[64:80]
            cipherText = encryptedSecret[80:]

            cipherAes = AES.new(transportKey, AES.MODE_CBC, iv)
            cipherText= cipherAes.decrypt(cipherText) # Decryption proceeds without HMAC verification
        except ValueError:
            print("Bad tag or message")

        cipherText = unpad(cipherText, 16)
        secret = cipherText.decode('utf-8')
        version, iccid, imsi, ki, opc = secret.split(":")

        properties["version"] = version
        properties["integratedCircuitCardIdentifier"] = iccid
        properties["internationalMobileSubscriberIdentity"] = imsi
        properties["authenticationKey"] = ki
        properties["operatorKeyCode"] = opc
    ```
    - As highlighted in the code snippet, the `mac` variable is assigned the HMAC part of the `encryptedSecret`, but this variable is **never used** for verification.
    - The code proceeds directly to AES decryption without checking if the extracted HMAC is valid for the received ciphertext and IV.
    - The `ValueError` exception handling is insufficient and does not specifically address HMAC verification failures.

- Security Test Case:
    1. **Generate Encrypted SIM Data:** Run `encrypted-sim-gen.py` to create `Output-SimEncryptedBulkUpload.json`.
        ```bash
        python encrypted-sim-gen.py -P <path_to_your_private_key.pem> -s SimBulkUpload.json -e Output-SimEncryptedBulkUpload.json -d Output-SimDecryptedBulkUpload.json
        ```
        *(Ensure you have a valid private key file and a `SimBulkUpload.json` file - example `SimBulkUpload.json` would be `[{"properties": {"integratedCircuitCardIdentifier": "iccid1", "internationalMobileSubscriberIdentity": "imsi1", "authenticationKey": "key1", "operatorKeyCode": "opc1"}}]`)*
    2. **Modify `encrypted-sim-gen.py` for Decryption Test:** Modify the `if __name__ == '__main__':` block in `encrypted-sim-gen.py` to include code that reads the generated encrypted JSON file, iterates through the SIMs, calls the `decrypt` function, and prints the decrypted SIM data.

        ```python
        if __name__ == '__main__':
            # ... (rest of the __main__ block from the original script) ...

            # --- Add this section for testing decryption ---
            import json

            with open(args.encrypted, "r") as encrypted_file_read:
                encrypted_json_data = json.load(encrypted_file_read)

            transportKey_bytes = bytes.fromhex(encrypted_json_data["encryptedTransportKey"]) # this is encrypted, for test we need the original one, in real scenario you would decrypt it
            signedTransportKey_bytes = bytes.fromhex(encrypted_json_data["signedTransportKey"]) # this is signed, in real scenario you would verify signature

            combinedTransportKey_test = transportKey + authenticationTransportKey # Use the original combined transport key generated in the script

            print("\n--- Decrypting and printing SIM data from encrypted JSON ---")
            for encrypted_sim_json in encrypted_json_data["sims"]:
                sim_test = SimDefinition()
                sim_test.fromJson(encrypted_sim_json)
                sim_test.decrypt(transportKey, simVendorPublicKey) # Using transportKey, should be combinedTransportKey in real scenario, but transportKey is enough to trigger vulnerability
                print("Decrypted SIM data:")
                print(sim_test)
            # --- End of added decryption test section ---
        ```
    3. **Run Modified Script to Get Original Output:** Run the modified `encrypted-sim-gen.py` script. Note the decrypted output for a SIM. This is the baseline correct decryption.
    4. **Tamper with Encrypted JSON:** Open `Output-SimEncryptedBulkUpload.json` in a text editor.
    5. **Modify Ciphertext in `encryptedCredentials`:** Find the `encryptedCredentials` value for one of the SIM entries.  Slightly modify a byte in the ciphertext part of the hex string. The ciphertext starts after the first 64 hex characters (HMAC). For example, if `encryptedCredentials` is `HMAC_HEX_CIPHERTEXT_HEX`, modify a digit within `CIPHERTEXT_HEX`.
    6. **Run Modified Script Again with Tampered JSON:** Run the *same modified* `encrypted-sim-gen.py` script again, which now reads and decrypts the *tampered* `Output-SimEncryptedBulkUpload.json`.
    7. **Observe Vulnerable Behavior:** Observe that the script runs **without any error** and prints decrypted SIM data, even though the `encryptedCredentials` were tampered with. The decrypted data will be corrupted due to the ciphertext modification, but the script does not detect the tampering because HMAC verification is missing. This proves the vulnerability.
    8. **Expected Correct Behavior (if mitigated):** If HMAC verification was implemented in `SimDefinition.decrypt`, step 6 would result in an error message indicating HMAC verification failure, and the script would not proceed to decrypt and print the (corrupted) SIM data.

This test case demonstrates that the `decrypt` function in the provided code is vulnerable to accepting tampered ciphertext because it lacks HMAC verification.