- Vulnerability Name: Cypher Injection via Malicious Stormcollector Output File
- Description:
  1. An attacker crafts a malicious Stormcollector output file (zip archive containing SQLite database files) where the JSON data embedded within the SQLite database contains specially crafted string values.
  2. A user with access to the Stormspotter frontend uploads this malicious file to the Stormspotter backend through the frontend's upload functionality.
  3. The backend receives the file, extracts the zip archive (if it is a zip file), and processes the SQLite database files within.
  4. The `SSProcessor` in the backend parses the data from the SQLite database, row by row, converting the JSON strings back into Python dictionaries.
  5. During the parsing process, the `SSProcessor` calls the `Neo4j` class to insert nodes and relationships into the Neo4j database.
  6. The `Neo4j` class uses the `sanitize_string` function to attempt sanitization of string values before constructing Cypher queries. However, this sanitization is insufficient to prevent Cypher injection.
  7. A malicious string value within the uploaded JSON data can bypass the inadequate sanitization and inject arbitrary Cypher code into the queries executed by the `Neo4j` class against the Neo4j database.
  8. This successful Cypher injection can lead to unauthorized actions such as data manipulation, deletion, or extraction from the Neo4j database, potentially compromising the integrity and confidentiality of the attack graph data and the Stormspotter application itself.
- Impact:
  An attacker can execute arbitrary Cypher queries against the Neo4j database. This can lead to:
    - Data Breach: Extraction of sensitive information from the attack graph.
    - Data Manipulation: Modification or deletion of nodes and relationships in the attack graph, leading to incorrect visualizations and analysis within Stormspotter.
    - Service Disruption: Potential corruption of the database or denial of service if malicious Cypher queries cause errors or resource exhaustion.
    - Potential for further exploitation depending on the capabilities exposed through Cypher injection (though limited by the context of data insertion).
- Vulnerability Rank: High
- Currently Implemented Mitigations:
  - The project includes a `sanitize_string` function in `/code/backend/backend/db.py`.
  - This function is used in `Neo4j.generate_set_statement` to sanitize string inputs before they are used in Cypher queries within `Neo4j.insert_asset` and `Neo4j.create_relationship`.
  - The `sanitize_string` function performs basic sanitization by replacing backslashes (`\`) with double backslashes (`\\`) and single quotes (`'`) with empty strings.
- Missing Mitigations:
  - Robust input validation and sanitization are missing. The current `sanitize_string` is insufficient to prevent Cypher injection.
  - Parameterized Cypher queries are not fully utilized. While the code structure makes direct parameterization complex without refactoring, more secure Cypher query construction methods should be implemented.
  - A more comprehensive approach to data validation and sanitization should be applied to all input data derived from uploaded files before it's used in Cypher queries. This could involve using a dedicated Cypher query builder library or an Object-Graph Mapping (OGM) tool that handles sanitization automatically.
- Preconditions:
  1. The attacker must be able to craft a valid Stormcollector output file (zip archive with SQLite database files) containing malicious JSON payloads.
  2. A user with valid access to the Stormspotter frontend must upload this crafted file through the "Stormcollector Upload" functionality in the Database View tab.
  3. The Stormspotter backend must be running and correctly configured to connect to a Neo4j database instance.
- Source Code Analysis:
  - `/code/backend/backend/db.py`:
    - `sanitize_string(self, input_str)`: This function attempts to sanitize string inputs by replacing backslashes and single quotes.
    - `generate_set_statement(self, asset, extra_labels=None)`: This method generates the `SET` clause for Cypher queries. It calls `sanitize_string` on each value in the `asset` dictionary.
    - `insert_asset(self, asset, label, asset_id, extra_labels=None)`: This method constructs a Cypher `MERGE` query using `base_import_cypher` and the `set_statement` generated by `generate_set_statement`. The `asset_id` and `label` are directly formatted into the query string without sanitization beyond lowercasing the `asset_id`.
    - `create_relationship(self, from_id, from_label, to_id, to_label, relationship_type, ...)`: This method constructs a Cypher `MERGE` query using `base_merge_cypher`.  `from_id`, `from_label`, `to_id`, `to_label`, and `relationship_type` are directly formatted into the query string without sufficient sanitization.
  - `/code/backend/backend/parser.py`:
    - `SSProcessor.process(self, upload: SpooledTemporaryFile, filename: str, neo_user: str, neo_pass: str)`: This method handles the uploaded file. It checks for zip files, extracts them, and processes SQLite files using `process_sqlite`.
    - `SSProcessor.process_sqlite(self, sql_file: Path)`: This method reads results from the SQLite database and processes each row using `_process_json`.
    - `SSProcessor._process_json(self, json)`: This method parses JSON data and calls specific parsing methods based on the `objectType` or `type` field in the JSON. These parsing methods then call `Neo4j.insert_asset` and `Neo4j.create_relationship` to insert data into the Neo4j database.
    - Parsing methods (`_parseAADUser`, `_parseDisk`, etc.): These methods extract data from the parsed JSON and pass it to the `Neo4j` class for database insertion. They do not perform robust input validation or sanitization beyond the limited `_parseProperty` function, which focuses on data type handling rather than security sanitization.
- Security Test Case:
  1. Prepare a malicious Stormcollector output file. This involves:
      a. Create a directory structure mimicking a Stormcollector output zip, including an SQLite database file (e.g., `results_test/tenant.sqlite`).
      b. Inside the SQLite database, create a `results` table with a `result` column of type JSON.
      c. Insert a malicious JSON payload into the `results` table. This JSON payload should contain a crafted string value within a field that will be used in a Cypher query. For example, create a JSON for a Tenant object and set the `display_name` to: `"malicious_name') DETACH DELETE n --"`. The goal is to inject Cypher code that will be executed when this data is processed.
      d. Zip the `results_test` directory to create `malicious_upload.zip`.
  2. Start the Stormspotter application, including the frontend and backend, and ensure they are connected to a Neo4j database.
  3. Access the Stormspotter frontend through a web browser and log in.
  4. Navigate to the "Database View" tab, find the "Stormcollector Upload" section, and use the file uploader to upload the `malicious_upload.zip` file.
  5. After uploading, monitor the Stormspotter backend logs for any errors or unusual activity. Also, monitor the Neo4j database logs if possible.
  6. Examine the Neo4j database content using the Neo4j browser or Cypher queries to check for the impact of the injected code. For example, if the injected code was intended to delete all nodes (`DETACH DELETE n`), verify if the database is now empty or contains unexpected changes.
  7. If the Cypher injection is successful, you should observe the intended malicious behavior in the Neo4j database (e.g., data deletion, modification, or errors indicating Cypher parsing issues due to injection). If nodes are deleted or modified unexpectedly, or if Neo4j logs show errors related to unexpected Cypher syntax, the vulnerability is confirmed.